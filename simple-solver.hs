-- Sudoku Solver
-- Functional Programming Final Project
-- Chloe Baker, Cookie, Kate Sanders

-- sudoku :: Board â†’ [Board]

import Data.List (transpose)


-- A Matrix is a list of lists containing elements of type a
-- The Board will be an N^2 x N^2 matrix
type Matrix a = [[a]]

-- Since our input for boards is in a .txt file, we make it into a Matrix of characters
type Board = Matrix Char

-- Choices is a synonym for a list of characters
type Choices = [Char]

-- TODO: Function that rejects invalid boards (some elements aren't in cellvals)

-- For now, we assume the board satisfied basic requirements

-- A matrix is given by a list of its rows
-- The rows are the matrix
rows :: Matrix a -> Matrix a
rows = id

-- Each row has a list of column values
-- The function cols should compute the transpose of a matrix
-- Ask Dr. Yorgey if we need to implement transpose ourselves
cols :: Matrix a -> Matrix a
cols xs = transpose xs

-- cols * cols = id
-- because taking the transpose of a matrix twice returns the original matrix

-- Groups a row into sublists of a given, equal size
groupByInteger ::  Int -> [a] -> [[a]]
groupByInteger i [] = []
-- We are splitting the list list xs at integer i, using the splitAt function
-- which returns a tuple of a list of the first i elements and then the rest of the list
-- we put the list of the first i element at the start of our list, then concatenate that
-- with a list of lists recursively generated by groupByInteger called with the remaining elements of the list
groupByInteger i xs = ys : groupByInteger i yss
    where 
        (ys, yss) = splitAt i xs

-- groups a list into component lists of length boxsize
group :: [a] -> [[a]]
group xs = groupByInteger (round (sqrt (fromIntegral (length xs)))) xs
-- This is assuming that xs is a perfect square

-- Puts the list of lists generated by groups into just the original list
ungroup :: [[a]] -> [a]
ungroup = concat

boxes :: Matrix a -> Matrix a
boxes m = map ungroup (ungroup (map cols (group (map group m))))
-- starts as a matrix and breaks each row into a list of lists of size boxsize
-- Then you group the rows together into groups of size boxsize 
-- Takes a transpose of the row lists, which will make a list of all of the rows in specific box
-- Ungroup them so we have a list of each box and each box is a list

-- notElem sees whether an element is in a given list
-- to see if there are no repeated elements, 
-- for each element, see whether that element is repeated in the rest of the list
-- as well as checking the elements in the rest of the list for duplicates recursively
nodups :: Eq a => [a] -> Bool
nodups [] = True
nodups (x : xs) = notElem x xs && nodups xs

-- all takes a function that returns a boolean and a list 
-- and returns whether that function returns true for every element in the list
-- correct just checks to see if there are no duplicates in any row, col, and box
correct :: Board -> Bool
correct b = all nodups (rows b) && all nodups (cols b) && all nodups (boxes b)

-- if the spot e is equal to the blank character, then return a list with all possible values for that spot
-- otherwise, return a list with just tha character
choose e = if blank e then cellvals else [e]
-- could refine this by giving a list of actual possibilities, not just every cellval
-- to make sure that there are no cellvals duplicated

-- for each element in the list, if that element is the blank character, generate all possible ways to fill in that blank
choices :: Board -> Matrix Choices
choices = map (map choose)

-- computes the cartesian product oa a list of lists
-- Ask Yorgey
cp :: [[a]] -> [[a]]
cp [] = [[]]
cp (xs : xss) = [x : ys | x <- xs, ys <- cp xss]

-- mcp = matrix cartesian product
-- It takes in a matrix that contains all choices for that spot on the board
-- make a cartesian product of each of the choices
-- it makes every possible matrices
mcp :: Matrix [a] -> [Matrix a]
mcp xs = cp (map cp xs)

-- First get a matrix that has has all choices for each cell
-- Then, it will generate all boards possble given these choices
-- Finally, it will only return the correct board(s)
sudoku :: Board -> [Board]
sudoku b = filter correct (mcp (choices b))


boardsize = 4
boxsize = 2
cellvals = "1234"
blank = (== '.')

matrix_a = [['1', '2', '3', '4'], ['3', '4', '1', '2'], ['2', '3', '4', '1'], ['4', '1', '2', '3']]

sudoku_test_1 = [['.', '2', '3', '4'], ['3', '4', '1', '2'], ['2', '3', '4', '1'], ['4', '1', '2', '3']]

-- *Main> sudoku sudoku_test_1
-- [["1234","3412","2341","4123"]]

sudoku_test_2 = [['.', '2', '3', '4'], ['3', '.', '1', '2'], ['2', '3', '4', '1'], ['4', '1', '2', '3']]

-- *Main> sudoku sudoku_test_2
-- [["1234","3412","2341","4123"]]

-- half of cells missing
sudoku_test_3 = [['.', '2', '3', '.'], ['.', '.', '1', '2'], ['.', '3', '.', '1'], ['4', '1', '.', '.']]
-- *Main> sudoku sudoku_test_3
-- [["1234","3412","2341","4123"]]

matrix_with_duplicates = [['1', '2', '3', '4'], ['1', '4', '1', '2'], ['2', '3', '4', '4'], ['4', '1', '2', '3']]

-- *Main> matrix_a
-- [[1,2,3,4],[3,4,1,2],[2,3,4,1],[4,1,2,3]]
-- *Main> rows matrix_a
-- [[1,2,3,4],[3,4,1,2],[2,3,4,1],[4,1,2,3]]
-- *Main> cols matrix_a
-- [[1,3,2,4],[2,4,3,1],[3,1,4,2],[4,2,1,3]]
-- *Main> boxes matrix_a
-- [[1,2,3,4],[3,4,1,2],[2,3,4,1],[4,1,2,3]]
-- *Main> correct matrix_with_duplicates
-- False